%
\documentclass[runningheads]{llncs}
\usepackage[german]{babel}
\usepackage{graphicx}
\usepackage{url}


\begin{document}
%
\title{Modellierung und Simulation 2019/2020 Conway's Game of Life}
\author{Louis Donath, Dario Klepoch}
%
\authorrunning{}
\institute{Potsdam University}


\maketitle              

\begin{abstract}
Conway's Game of Life ist ein Automat...
Hier kommt eine kurze Zusammenfassung des Projektes rein
%\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%

\begin{section}{Einfuehrung}
    `Conways game of life' 
\end{section}

\section{Erklaerung unserer Implementierung}
    

\begin{section}{Implementierung}
    
    Bei der Betrachtung der Implementierung werden wir ueber die Implementierung der Randbedingungen sprechen.
    Weil wir mit unseren ersten Implementierung mit einer unzureichenden Performance hatten,
    werden wir im zweiten Teil ueber Performanceverbesserungen sprechen.
   
    

    \subsection{Randbedingungen}
        In unserer Implementierung des GoL haben wir drei unterschiedliche Randbedingungen implementiert.
        Eine Randbedingung sagt aus wie sich das Spiel verh√§lt, wenn auf Zellen ausserhalb des Spielbrettes zugegriffen wird.
        
        \subsubsection{Absorbierende Randbedingung} bedeutet das jede Zelle die ausserhalb des Spielbrettes ist als tot angenommen wird.
        
        \subsubsection{Periodische Randbedingungen} 

        \subsubsection{Reflektierende Randbedingungen}

        Wir haben die Randbedingungen implementiert wie man den Schemata in Tabelle \ref{randbedingungen} entnehmen kann.
        Auf der linken Seite ist die periodische Randbedingung gezeigt und auf der rechten Seite die reflektierende.
        In der Mitte ist das eigentlich Spielbrett mit den Zahlen $1..9$ dargestellt.
        Darum herum sind (gespiegelte) Kopien des Spielbrettes gezeigt.
        Die Zahlen $1'..9'$ symbolisieren Referenzen zu dem Spielbrett in der Mitte.
        Daher wenn die Zelle 1 lebt, leben auch alle Zellen 1'.
        Wenn sich nun eine Zelle auf den Rand zu bewegt wird sie bei der periodischen Randbedingung am Anfang des Spielbrettes neu erscheinen.


            \begin{table}
                \centering
                \caption{Darstellung der Randbedingungen}
                \label{randbedingungen}
                \begin{tabular}{ | c c c | c c c | c c c | }
                    \hline
                    1' & 2' & 3' & 1' & 2' & 3' & 1' & 2' & 3' \\
                    4' & 5' & 6' & 4' & 5' & 6' & 4' & 5' & 6' \\
                    7' & 8' & 9' & 7' & 8' & 9' & 7' & 8' & 9' \\
                    \hline
                    1' & 2' & 3' & \textbf{1}  & \textbf{2}  & \textbf{3}  & 1' & 2' & 3' \\
                    4' & 5' & 6' & \textbf{4}  & \textbf{5}  & \textbf{6}  & 4' & 5' & 6' \\
                    1' & 2' & 3' & \textbf{7}  & \textbf{8}  & \textbf{9}  & 7' & 8' & 9' \\
                    \hline
                    1' & 2' & 3' & 1' & 2' & 3' & 1' & 2' & 3' \\
                    4' & 5' & 6' & 4' & 5' & 6' & 4' & 5' & 6' \\
                    7' & 8' & 9' & 7' & 8' & 9' & 7' & 8' & 9' \\
                    \hline
                \end{tabular}
                \begin{tabular}{ | c c c | c c c | c c c | }
                    \hline
                    9' & 8' & 7' & 7' & 8' & 9' & 7' & 8' & 9' \\
                    6' & 5' & 4' & 4' & 5' & 6' & 4' & 5' & 6' \\
                    3' & 2' & 1' & 1' & 2' & 3' & 3' & 2' & 1' \\
                    \hline
                    3' & 2' & 1' & \textbf{1}  & \textbf{2}  & \textbf{3}  & 3' & 2' & 1' \\
                    6' & 5' & 4' & \textbf{4}  & \textbf{5}  & \textbf{6}  & 6' & 5' & 4' \\
                    9' & 8' & 7' & \textbf{7}  & \textbf{8}  & \textbf{9}  & 9' & 8' & 7' \\
                    \hline
                    9' & 8' & 7' & 7' & 8' & 9' & 9' & 8' & 7' \\
                    6' & 5' & 4' & 4' & 5' & 6' & 6' & 5' & 4' \\
                    3' & 2' & 1' & 1' & 2' & 3' & 3' & 2' & 1' \\
                    \hline
                \end{tabular}
            \end{table}

    \subsection{Performance}

    \subsubsection{Nachbarn ermitteln}

    \subsubsection{Partielle Updates}
        Nach der ersten Implementierung des GoL war die Performance 

    \subsubsection{Numpyarray anstatt Pythonlist}
        Um die Zeit 

    
    \subsubsection{Weitere Performancesteigerung}
        sind durch sehr viele unterschiedliche Veraenderungen moeglich.
        Eine sehr grossen Performancesteigerung ist dadurch moeglich einen effizientere Datenstruktur als ein (numpy-)array zu verwenden.
        In verschiedenen anderen Implementierungen des GoL wird hierfuer ein Quadtree benutzt.
        Ein Quadtree wird meistens dafuer verwendet effizient 2-dimensionale Daten zu speichern \cite{quadtreeGeeksForGeeks}.
        Da das GoL auch 2D-Daten sind ist es ein perfekter Anwendungsbereich fuer einen Quadtree.
        Mit `Haslife' wurde das GoL auf diese Weise implementiert \cite{haslifeWiki}. \newline
        Um die Performance noch weiter zu steigern ist es moeglich den Quadtree parallel aufzubauen.
        Hier kann entweder die CPU oder auch die GPU benutzt werden.
        In \cite{quadtreesOnGPU} wurden lineare Quadtrees verwendet um einen Quadtree vollstaendig auf der GPU aufzubauen.

\end{section}


\begin{thebibliography}{8}
\bibitem{quadtreeGeeksForGeeks}
    \url{https://www.geeksforgeeks.org/quad-tree/}, letzter Zugriff: 27.3.2020

\bibitem{haslifeWiki}
    \url{https://en.wikipedia.org/wiki/Hashlife}, letzter Zugriff: 27.3.2020

\bibitem{quadtreesOnGPU}
    Dupuy, Jonathan \& Iehl, Jean-Claude \& Poulin, Pierre. (2018).
    Quadtrees on the GPU. 10.1201/9781351052108-12. 

\end{thebibliography}
\end{document}
